시간 복잡도, 분할 정복 알고리즘 예시 O(n*logn)
======================================
# 분할 정복을 이용한 최대 연속 부분합

배열 `A[0..N-1]`의 **최대 연속 부분합**은 다음 세 가지 경우 중 하나에 속합니다.

1. **왼쪽 절반 내부**  
   - 최적 부분배열이 `left = A[0..mid]` 안에만 존재하는 경우

2. **오른쪽 절반 내부**  
   - 최적 부분배열이 `right = A[mid+1..N-1]` 안에만 존재하는 경우

3. **중간을 가로지르는 경우**  
   - 최적 부분배열이 `mid`와 `mid+1` 사이를 지나며,  
     `left`의 **최대 접미사 합** + `right`의 **최대 접두사 합** 으로 표현된다.
```c
#include <stdio.h
#include <inttypes.h>

#define MAX(x, y) ((x) > (y) ? (x) : (y))

// A[lo..hi]의 연속된 부분 구간의 최대 합을 구한다.
int fastMaxSum(const int *A, int lo, int hi) {
  // 기저 사례: 구간의 길이가 1일 경우
  if (lo == hi) return A[lo];
  // 배열을 A[lo..mid], A[mid+1..hi]의 두 조각으로 나눈다.
  int mid = (lo + hi) / 2;
  // 두 부분에 모두 걸쳐 있는 최대 합을 구한다. 이 구간은
  // A[lo..mid]와 A[mid..hi] 형태를 갖는 구간의 합으로 이루어진다.
  // A[lo..mid]배열의 '접미사'형태를 갖는 최대 구간을 찾는다.
  int left = INT32_MIN, right = INT32_MIN, sum = 0;
  for (int i = mid; i >= lo; --i) {
    sum += A[i];
    left = MAX(left, sum);
  }
  // A[mid + 1..hi]배열의 '접두사' 형태를 갖는 최대 구간을 찾는다.
  sum = 0;
  for (int i = mid + 1; i <= hi; ++i) {
    sum += A[i];
    right = MAX(right, sum);
  }
  // 최대 구간이 두 조각 중 하나에만 속해 있는 (최대 부분 배열이 두 조각을 가로지르지 않는)경우의 답을 재귀 호출로 찾는다.
  int single = MAX(fastMaxSum(A, lo, mid), fastMaxSum(A, mid + 1, hi));

  // 두 경우 중 최대치를 반환한다.
  return MAX(left + right, single);
}
```